<!DOCTYPE html>
<html lang="en">
    <head>
        <title>map() | JS CodeyLuwak</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" type="image/x-icon" href="./img/keyboard-5-16.ico">
        <link rel="stylesheet" href="./style.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,400;0,700;1,400;1,700&family=Fira+Mono:wght@400;500;700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    </head>

    <body>

        <header>
            <a href="./index.html"><h1>JavaScript: Array.prototype.map()</h1></a>
            <nav id="navMenu"></nav>
        </header>

        <main class="js-notes">

            <article id="map-method">
                <h2>Array.prototype.map()</h2>

                <dl>
                    <dt><code>map()</code></dt>
                    <dd>Calls one same provided callback function once for each element in original array and constructs a new array from the results.</dd>
                    <dd>In other word: The new array consists of the callback function result on each of the element.</dd>
                    <dd>Just think the new array is a map image of the original.</dd>
                    <dd>
                        <div class="formula"><code>
                        map(<span class="variable">...</span>)
                        </code></div>
                    </dd>

                    <dt>Syntax</dt>                  
                    <dd>
<pre class="formula">
<span class="comment">// Callback function</span>
map(<span class="variable">callbackFn</span>)
map(<span class="variable">callbackFn</span>, <span class="variable">thisArg</span>)


<span class="comment">// Inline callback function</span>
map(<span class="variable">function (element) {...}</span>)
map(<span class="variable">function (element, index) {...}</span>)
map(<span class="variable">function (element, index, array) {...}</span>)
map(<span class="variable">function (element, index, array) {...}</span>, <span class="variable">thisArg</span>)

<span class="comment">// Arrow function</span>
map(<span class="variable">(element) => {...}</span>)
map(<span class="variable">(element, index) => {...}</span>)
map(<span class="variable">(element, index, array) => {...}</span>)
</pre>
                    </dd>
                    <dd>
                        <dl>
                            <dt>Parameters (2):</dt>
                            <dd>
                                <ul>
                                    <li>Callback function</li>
                                    <li>thisArg (optional) : Value to use as <code>this</code> when running callback function. <code>undefined</code> is assigned if not provided.</li>
                                </ul>
                            </dd>

                            <dt>Return value:</dt>
                            <dd>New array with each element being the result of the callback function.</dd>

                            <dt>Original array:</dt>
                            <dd>In general: not changed.</dd>
                            <dd>Unless manipulated during the map-callback function run, through access to the original array using array and index parameters. This is generally avoided, except in some special cases.</dd>
                        </dl>
                    </dd>    

                    <dt>Callback function</dt>
                    <dd>
<pre class="formula">
function <span class="variable">callbackFn</span>(<span class="variable">element, index, array</span>) {
    <span class="variable">...</span>
    return <span class="variable">new element value</span>;
}
<span class="comment">// Element is pushed to the new array. It will occupy the same index.</span>
</pre>
                    </dd>

                    <dd>
                        <dl>
                            <dt>Parameters (3):</dt>
                            <dd>
                                <ul>
                                    <li><code>element</code> : Current element being process</li>
                                    <li><code>index</code> (optional): index of current element being process</li>
                                    <li><code>array</code> (optional): The original array</li>
                                </ul>
                            </dd>
 
                            <dt>Return values:</dt>
                            <dd>
                                <ul>
                                    <li>New element value for the new array.</li>
                                </ul>
                            </dd> 
                            
                            <dt>Map function is invoked only for cells with assigned values, including <code>undefined</code>.</dt>
                            <dd>It is not called for missing elements of the array.</dd>
                            <dd>
                                <ul>
                                    <li>Indexes that have never been set</li>
                                    <li>Indexes which have been deleted</li>
                                </ul>
                            </dd>
                            <dt><code>empty</code> cell?</dt>
                            <dd>It's included in the new array, but map function is not called. I guess, it could have been merely "nothing is put in that cell" and the next element will go to the subsequent index.</dd>
                            <dd>
<pre class="formula-thin">
const array = [1, "a", , undefined, null, NaN, true, false];

const map1 = array.map(el => el);
const map2 = array.map(el => !el);
const map3 = array.map(el => "cat");

array;  // (8) [1, 'a', empty, undefined, null, NaN, true, false]
map1;   // (8) [1, 'a', empty, undefined, null, NaN, true, false]
map2;   // (8) [false, false, empty, true, true, true, false, true]
map3;   // (8) ['cat', 'cat', empty, 'cat', 'cat', 'cat', 'cat', 'cat']

let counter = 0;
const map4 = array.map(el => {counter++; return el});
counter;    // 7
map4;       // (8) ['z', 'z', empty, 'z', 'z', 'z', 'z', 'z']
</pre>
                            </dd>
                            <dd>See that <code>empty</code> is included in the result list, but map function is not called. Evidence: empty spot, and counter is only 7.</dd>
                            <dd>Let's compare with similar operations in filter.</dd>
                            <dd>
<pre class="formula-thin">
const array = [1, "a", , undefined, null, NaN, true, false];

const filter1 = array.filter(el => el);
const filter2 = array.filter(el => !el);
const filter3 = array.filter(el => el || !el);

array;  // (8) [1, 'a', empty, undefined, null, NaN, true, false]
filter1;   // (3) [1, 'a', true]
filter2;   // (4) [undefined, null, NaN, false]
filter3;   // (7) [1, 'a', undefined, null, NaN, true, false]

let counter = 0;
const filter4 = array.filter(el => {counter++; return el || !el});
counter;    // 7
filter4;    // (7) [1, 'a', undefined, null, NaN, true, false]
</pre>
                        </dd>
                        <dd>See that the function is not called for empty cell either. Counter is also only 7. Also in the result array, at most we get 7 elements.</dd>
                        </dl>
                    </dd>
                    <dt>When to not use <code>map()</code>?</dt>
                    <dd>When we are not going to use the new array</li>
                    <dd>Example of good use:
                        <ul>
                            <li>When the new array is needed as an input for other function/request with certain value/format.</li>
                            <li>When array is to be sent out to a third party and they don't need / should not see the complete information.</li>
                        </ul>
                    </dd>
                    <dt>What actually happen when <code>map()</code> is called</dt>
                    <dd>
                        <ul>
                            <li>Very similar to <code>filter()</code> except it creates new array of new values according to callback function.</li>
                            <li>When <code>map</code> is called, it sees the cells that are there. Only to those cells, the callback function will be called.
                                <ul>
                                    <li>New future cells created during the callback function run will be ignored</li>
                                    <li>If content is shifted or changed, then whatever new value populate the cell will be used.</li>
                                </ul>
                            </li>
                            <li>It doesn't call the callback function when the cell is empty or not existing. But even when the callback function is not called, the cell with the same index is already assigned in the new array. They will be left empty as well.
                                <ul>
                                    <li>Cells that are empty because the value is never assigned. This cells marked as <code>empty</code> in the array.
                                        <ul>
                                            <li>Remember, <code>undefined</code> is an assigned value.</li>
                                            <li>As well as <code>null</code> and <code>NaN</code>. Well, <code>NaN</code>'s type is actually <code>number</code></li>
                                        </ul>
                                    </li>
                                    <li>Cells that are empty upon deletion (like with <code>delete</code> operator).</li>
                                    <li>Cells that are removed after <code>map()</code> is called, for example by <code>pop()</code> method from callback function.</li>
                                </ul><br>
                                So these <code>empty</code> cells are mapped <code>empty</code> too in the new array.
                            </li>
                            <li>For each cell, callback function is called. Current cell value of the original array is used. This could be different from original array value when <code>map()</code> is initiated, if previous cell run changed the value of the consequent one.Callback function results in a value. This value is added to the new array cell with the same index.</li>
                            <li>New array has the same length as the original array. Each cell value is transformed from the original cell value of the same index. Empty stays empty.</li>
                            <li>In the end, we have 2 array. Original and map result.</li>
                        </ul>
                    </dd>


                </dl>
                <a href="#top"><hr></a>
            </article>

            <article id="simpel-map">
                <h2>Example: Simple map</h2>

                <dl>
                    <dt>Map numbers to their square roots</dt>
                    <dd>Given: array of numbers</dd>
                    <dd>
<pre class="formula-thin">
const <span class="variable">numberArray</span> = [<span class="variable">1, 2, 3, 4, 5</span>];
</pre>
                    </dd>
                    <dd>Map to the square root</dd>
                    <dd>
<pre class="formula">
const <span class="variable">rootArray</span> = <span class="variable">numberArray</span>.map(<span class="variable">num</span> => <span class="variable">Math.sqrt(num)</span>);
</pre>
                    </dd>
                    <dd>Results</dd>
                    <dd>
<pre class="formula-thin">
<span class="variable">numberArray</span>;    <span class="comment">// (5) [1, 2, 3, 4, 5]</span>
<span class="variable">rootArray</span>;      <span class="comment">// (5) [1, 1.4142135623730951, 1.7320508075688772, 2, 2.23606797749979]</span>
</pre>
                    </dd>
                    
                </dl>
                <a href="#top"><hr></a>
            </article>

            <article id="reformat-array">
                <h2>Example: Reformat array</h2>

                <dl>
                    <dt>Common map use is to create array with a certain format. In this example, remove the property names.</dt>
                    <dd>Given: an object array</dd>
                    <dd>
<pre class="formula-thin">
const <span class="variable">keyData</span> = [<span class="variable">
    { key: 1, value: 10 },
    { key: 2, value: 20 },
    { key: 3, value: 30 }
</span>];
</pre>
                    </dd>
                    <dd>Map to plain object array without property names</dd>
                    <dd>
<pre class="formula">
const <span class="variable">keyReady</span> = <span class="variable">keyData</span>.map(<span class="variable">({ key, value })</span> => <span class="variable">({ [key]: value })</span>);
</pre>
                    </dd>
                    <dd>Results</dd>
                    <dd>
<pre class="formula-thin">
<span class="variable">keyReady</span>;
<span class="comment">/* [{ 1: 10 },
    { 2: 20 },
    { 3: 30 }]; */</span>

<span class="comment">// keyData remains unchanged</span>
</pre>
                    </dd>
                    
                </dl>
                <a href="#top"><hr></a>
            </article>

            <article id="string-map-call">
                <h2>stringMap.call()</h2>
                <h3>Creating map-like function for string use</h3>

                <dl>                                      
                    <dt><code>map.call()</code> for string manipulation</dt>
                    <dd>String can be seen as an array of characters. With a little modification, we can adapt array's <code>map()</code> functionality for a string use. Let's call this string map mimic <code>stringMap</code>.</dd>
                    <dd><b>Creating <code>stringMap</code></b></dd>
                    <dd>
                        <code class="formula">const <span class="variable">stringMap</span> = <span class="variable">Array.prototype.map;</span></code>
                    </dd>
                    
                    <dd><b>Calling <code>stringMap</code></b></dd>
                    <dd>
                        <code class="formula"><span class="variable">stringMap</span>.call(<span class="variable">text</span>, <span class="variable">charFunc</span>);</code>
                    </dd>

                    <dt>String mapping example</dt>
                    <dd>Task: Create an array from character code of each characters from a text.</dd>
                    <dd>Remember summary above:</dd>
                    <dd>
                        <ul>
                            <li>Creating <code>stringMap</code><br>
                                <code class="formula-thin">const <span class="variable">stringMap</span> = <span class="variable">Array.prototype.map;</span></code>
                            </li>
                            <li>Calling <code>stringMap</code><br>
                                <code class="formula-thin"><span class="variable">stringMap</span>.call(<span class="variable">text</span>, <span class="variable">charFunc</span>);</code>                    
                            </li>
                        </ul>
                    </dd>
                    
                    <dd>We only need to prepare the character function <code>charFunc</code>.</dd>
                    <dd>
                        <ul>
                            <li>We can use handy string prototype <code>charCodeAt(index)</code>. Since it's already run for each character, index will be <code>0</code>.</li>
                        <li>Since character function is short, it can be written as unnamed as an arrow function<br>                        
                            <code class="formula-thin"><span class="variable">char</span> =&gt; <span class="variable">char</span>.charCodeAt(0);</code></li>
                        </ul>                
                    </dd>

                    <dd>Then let's try:</dd>
                    <dd>
<pre class="formula-thin">
const <span class="variable">stringMap</span> = <span class="variable">Array.prototype.map;</span>

<span class="variable">stringMap</span>.call(<span class="variable">"Hello World"</span>, <span class="variable">char => char.charCodeAt(0)</span>)
<span class="comment">// (11) [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]</span>
</pre>
                    </dd>
                    
                    <dt>Breakdown</dt>
                    <dd>
                        <dl>
                            <dt>Array <code>map()</code> syntax:</dt>
                            <dd>
                                <code class="formula-thin"><span class="variable">arr</span>.map(<span class="variable">elementFunc</span>)</code>
                            </dd>
                            <dd>Here we have:
                                <ul>
                                    <li><code>map()</code>: The map method for array</li>
                                    <li><code>arr</code>: The array needs to be operated.</li>
                                    <li><code>elementFunc</code>: Operation function for each element of the array.</li>
                                </ul>
                            </dd>

                            <dt><code>stringMap</code></dt>
                            <dd><code>stringMap</code> will take <b>a string</b> as the object, and apply <b>a function</b> to each of the characters of the text, and create a new text from the sequence of the results.</dd>
                            <dd>Let's name the string "<code>text</code>" and the character function "<code>charFunc</code>".</dd>
                            <dd>Now we have:
                                <ul>
                                    <li><code>stringMap</code>: The map-mimic for string</li>
                                    <li><code>text</code>: The string needs to be operated.</li>
                                    <li><code>charFunc</code>: Operation function for each character of the string.</li>
                                </ul>
                            </dd>
                            <dd>But right now coining them into <code>text.stringMap(charFunc)</code> won't work.</dd>
                            <dd><code>stringMap</code> doesn't even exist yet. We first need to define it and unfortunately it's not going to be the same syntax since it's not a string prototype.</dd>
                            <dd>We are going to use <code>call()</code> to coin them together.</dd>

                            <dt>General <code>call()</code> syntax:</dt>                    
                            <dd>
                                <code class="formula-thin">function <span class="variable">func</span>(<span class="variable">args</span>) {<span class="variable">...</span>}</code>
                            </dd>
                            <dd>
                                <code class="formula"><span class="variable">func</span>.call(<span class="variable">obj</span>, <span class="variable">args</span>)</code>
                            </dd>   
                            <dd>Parameters:
                                <ul>
                                    <li><code>obj</code>: Object to which the function is to be operated.</li>
                                    <li><code>args</code>: Is a comma-separated list of arguments for the original function.                                 
                                        <ul>
                                            <li>In <code>map()</code>, this will be the <code>elementFunc</code>.</li>
                                            <li>For our <code>stringMap</code>, let's call it <code>charFunc</code>.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </dd>
                            
                            <dt>Creating <code>stringMap</code> function for <code>call()</code> use</dt>   
                            <dd>The <code>func</code> function to be called here is <code>stringMap</code></dd>
                            <dd>
        <pre class="formula">
        const <span class="variable">stringMap</span> = <span class="variable">Array.prototype.map</span>

        <span class="comment">// Taking a character-function as argument.</span>
        </pre> 
                            </dd>
                            <dd>Breakdown:
                                <ul>
                                    <li>Imagine we need function <code>stringMap</code> like this:<br>
                                        <code class="formula-thin">function <span class="variable">stringMap</span>(<span class="variable">args</span>) {<span class="variable">...</span>}</code>
                                    </li>
                                    <li>But it's created from <code>Array.prototype.map</code> directly.<br>
                                        <code class="formula-thin">const <span class="variable">stringMap</span> = <span class="variable">Array.prototype.map</span></code>

                                    </li>
                                    <li>Remember, even though it's not listed here, <code>map()</code> is taking the <code>elementFunc</code> as argument.<br>
                                        
                                        <code class="formula-thin"><span class="variable">arr</span>.map(<span class="variable">elementFunc</span>)</code>
                                    </li>
                                    <li>For <code>stringMap</code>, that's <code>charFunc</code>. Imagine:<br>
                                        <code class="formula-thin">function <span class="variable">stringMap</span>(<span class="variable">charFunc</span>) {<span class="variable">...</span>}</code>
                                    </li>
                                </ul>
                            </dd>
                            
                            <dt>Constructing <code>stringMap.call()</code></dt>

                            <dd>Now <code>stringMap</code> is in the right format to be called using <code>call()</code>.<br>
                                <code class="formula-thin"><span class="variable">stringMap</span>.call(<span class="variable">obj</span>, <span class="variable">args</span>)</code>
                            </dd>
                            <dd>Parameters for <code>stringMap</code>:
                                <ul>
                                    <li><code>obj</code> is the object to which function <code>stringMap</code> is operated, that is <code>text</code> (the string).</li>
                                    <li><code>args</code> is the arguments to the function <code>stringMap</code> which is <code>charFunc</code> (function for each character).</li>
                                </ul>
                            </dd>
                            <dd>
                                <code class="formula"><span class="variable">stringMap</span>.call(<span class="variable">text</span>, <span class="variable">charFunc</span>)</code>
                            </dd>
                            <dd>That's it</dd>
                        </dl>
                    </dd>
                    
                </dl>
                <a href="#top"><hr></a>
            </article>
            
            <article id="template">
                <h2>template</h2>

                <dl>
                    <dt>template</dt>
                    <dd>Given: array</dd>
                    <dd>
<pre class="formula-thin">
const <span class="variable">template</span> = [<span class="variable">template</span>];
</pre>
                    </dd>
                    <dd>Map</dd>
                    <dd>
<pre class="formula">
const <span class="variable">template</span> = <span class="variable">template</span>.map(<span class="variable">template</span> => <span class="variable">template</span>);
</pre>
                    </dd>
                    <dd>Results</dd>
                    <dd>
<pre class="formula-thin">
<span class="variable">template</span>;    <span class="comment">// template</span>
<span class="variable">template</span>;      <span class="comment">// template</span>
</pre>
                    </dd>
                    
                </dl>
                <a href="#top"><hr></a>
            </article>

            <article id="template2">
                <h2>template</h2>
                <h3>template</h3>

                <dl>
                    <dt>template</dt>
                    <dd>Given: array</dd>
                    <dd>
<pre class="formula-thin">
const <span class="variable">numbers</span> = [<span class="variable"></span>];
</pre>
                    </dd>
                    <dd>template</dd>
                    <dd>
<pre class="formula-thin">
<span class="variable">template</span>
<span class="comment">template</span>
</pre>
                    </dd>
                    <dd>template</dd>
                </dl>
                <a href="#top"><hr></a>
            </article>

           

            <article id="references">
                <h2>References</h2>
                <ul>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">MDN: Array.prototype.map()</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank">MDN: Function.prototype.call()</a></li>

                </ul>
            </article>
        </main>
        <footer>
            <div class="nav-bar"><a href="./index.html" class="nav-button-rev" style="margin: auto">Home</a></div>
        </footer>
        <script src="./navArticle.js"></script>
    </body>
</html>

