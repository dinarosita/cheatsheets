<!DOCTYPE html>
<html lang="en">
  <head>
    <title>React | Hooks</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="./img/keyboard-5-16.ico" />
    <link rel="stylesheet" href="./style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,400;0,700;1,400;1,700&family=Fira+Mono:wght@400;500;700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <!--Clickable Page Title-->
    <header>
      <a href="./index.html"><h1>React Hooks</h1></a>
      <nav id="navMenu"></nav>
    </header>

    <main class="react_notes">
      <article id="useState">
        <h2>
          <a href="./react_usestate.html">useState</a>
        </h2>

        <p class="tagline">Create and update states</p>

        <pre
          class="formula"
        >const [<span class="variable">state</span>, <span class="variable">setState</span>] = useState(<span class="variable">initialValue</span>)</pre>

        <p><code>useState</code> is a hook that create states and manage updates to it. <code>useState</code> always returns 2 values: the new <code>state</code> and function <code>setState</code> that update the state. An <code>initialValue</code> can be added as a parameter. This value will be used upon page refresh. While for the subsequent rendering, latest <code>state</code> value will be used. Until <code>setState</code> set a new <code>state</code> value. And so on.</p>

        <p>T</p>

        <p>
          How it works: Constant state is created with an initial value, and
          setState is a function that will update state everytime it is called.
        </p>


        <p>
          When there's certain state that applies within a rendered page, and
          the state can be changed around, hook <code>useState</code> is used to
          manage this. <code>useState</code> always return 2 values in an array
          format: the current state and a function to change the state. An
          initial state can be included as a parameter. This initial state can
          be a value or a function call.
        </p>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useEffect">
        <h2>
          <a href="./react_useeffect.html">useEffect</a>: perform side effects
          based on changing dependencies
        </h2>

        <pre
          class="formula"
        >useEffect(() => {<span class="variable">...codes...</span>}, [<span class="variable">dependencies</span>])</pre>

        <p>
          This hook is for triggering side effect to happen in respond to
          changes in its dependencies.
        </p>

        <p>
          The codes run asynchronously to the rendering, allowing the main
          rendering to be done without waiting side effect to finish.
        </p>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useLayoutEffect">
        <h2>
          <a href="./react_uselayouteffect.html">useLayoutEffect</a>: Similar to
          useEffect but for layout that must execute before the painting of the
          screen
        </h2>
        <p>
          <code>useLayoutEffect</code> is similar to <code>useEffect</code>,
          except it happens synchronously, between DOM calculation and screen
          painting, so the layout effects it creates will be taken into account
          into the painting of the screen. <code>useEffect</code> happens
          asynchronously and get incorporated anytime handy. Therefore if the
          side effect is on the layout, it might cause a layout jump especially
          when it's slow.
        </p>
        <p>
          This hook can be useful for when the side effect matters for the
          layout, but could be slow. So only use when it's needed.
        </p>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useMemo">
        <h2>
          <a href="./react_usememo.html">useMemo</a>: memoize last values for
          next rendering
        </h2>

        <pre class="formula">
const <span class="variable">lastReturn</span> = useMemo(() => {
    <span class="variable">...</span>
    return <span class="variable">theReturn</span>
}, [dependencies])</pre>

        <p>
          In a function component, everything gets rerendered including those
          that doesn't need to change. If we have a slow but rarely used
          function, it will get rerendered as well each time, causing every
          render becoming slow unnecessarily. In this situation, we use hook
          <code>useMemo</code> (memoization). It's caching the computed value.
          Hook <code>useMemo</code> will only recompute the memoized value when
          one of the <code>deps</code> (dependancies) has changed. Otherwise, it
          will use the memoized value.
        </p>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useRef">
        <h2>
          <a href="./react_useref.html">useRef</a>: Persist values between
          renders
        </h2>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useContext">
        <h2>
          <a href="./react_usecontext.html">useContext</a>: Pass data and states
          through component tree
        </h2>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useReducer">
        <h2>
          <a href="./react_usereducer.html">useReducer</a>: Store and update
          states
        </h2>
        <p>
          <code>useReducer</code> is like <code>useState</code>, that it manages
          states and rerender component whenever the state changes.
          <code>useReducer</code> gives more concrete way to handle more complex
          function. <code>useReducer</code> has very similar pattern and use
          with <code>redux</code>, but it takes away a lot of boiler plate from
          <code>redux</code>.
        </p>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useCallback">
        <h2>
          <a href="./react_usecallback.html">useCallback</a>: Cache function
          between rerendering. Like <code>useMemo</code>, but for functions.
        </h2>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useTransition">
        <h2>
          <a href="./react_usetransition.html">useTransition</a>: Hook to make
          react app faster and more responsive to improve user experience
        </h2>

        <p>
          It works by giving priority to tasks within the function, so the
          higher priority one doesn't need to wait the lower priority one. It
          will render them separately.
        </p>

        <p>
          Only use this hook when it's absolutely needed, because this hook
          cause much more rendering than normal. Can unnecesarrily burdening if
          not actually needed. Only use it when running into performance issue.
        </p>

        <pre class="formula">
const [isPending, startTransition] = useTransition()</pre
        >

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useReferredValue">
        <h2><a href="./react_usedeferredvalue.html">useDeferredValue</a>:</h2>
        <p>
          This hook improve sluggishness and responsiveness by bunching up state
          changes together. Say we have input box that capture change every key
          stroke and every change trigger response. This can be unnecessarily
          too frequent. Using <code>useDeferredValue</code>, state changes can
          be collected until it's handy for react to render together. For using,
          just wrap the wanted state like this:
        </p>

        <pre
          class="formula"
        >const <span class="variable">deferredState</span> = useDeferredValue(<span class="variable">state</span>)</pre>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useImperativeHandle">
        <h2>
          <a href="./react_useimperativehandle.html">useImperativeHandle</a>:
        </h2>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useDebugValue">
        <h2><a href="./react_usedebugvalue.html">useDebugValue</a>:</h2>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useId">
        <h2><a href="./react_useid.html">useId</a>:</h2>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useInsertionEffect">
        <h2>
          <a href="./react_useinsertioneffect.html">useInsertionEffect</a>:
        </h2>

        <a href="#top"><hr /></a>
      </article>
      
      <article id="useSyncExternalStore">
        <h2>
          <a href="./react_usesyncexternalstore.html">useSyncExternalStore</a>:
        </h2>

        <a href="#top"><hr /></a>
      </article>
    </main>
    <footer>
      <a href="#top" class="nav-button-rev" style="margin: auto">Top</a>
      <a href="./index.html" class="nav-button-rev" style="margin: auto"
        >Home</a
      >
    </footer>
    <script src="./navArticle.js"></script>
  </body>
</html>
